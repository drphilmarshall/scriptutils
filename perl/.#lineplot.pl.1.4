#!/usr/local/bin/perl
# ======================================================================
#+
$usage = "\n
NAME
        lineplot.pl

PURPOSE
        Plot two or three column plain text files as connected points
        with error bars.

USAGE
        lineplot.pl [flags] [options] \$project.txt \$other.txt ...

FLAGS
        -u        Print this message
        -l        Connect points with a line
        -p        Plot data points
        -e        Plot error bars
        -logx     Logarithmic x axis
        -logy     Logarithmic y axis
        -q        Plot quietly (no X display)

INPUTS
        \$project.txt        3 column text file (x, y, error)

OPTIONAL INPUTS
        -v        i         Verbosity (0, 1 or 2)
        -xmin     f         Window xmin
        -xmax     f         xmax
        -ymin     f         ymin
        -ymax     f         ymax
        -color    i         PGPLOT color index
        -lw       i         PGPLOT line width
        -ls       i         PGPLOT line style
        -ch       f         PGPLOT character height
        -o        \$project  Postscript output file

        \$other.txt          Additional text file

OUTPUTS
        \$project.ps         Postscript plot

COMMENTS
  - PGPLOT module requires /usr/local/bin/perl at KIPAC

EXAMPLES

BUGS
  - Colouring is hard-coded
  - No legends are added to graph

REVISION HISTORY:
  2005-08-02  Started Marshall and Cevallos (KIPAC)

\n";

#-
# ======================================================================

use PGPLOT;

# Parse options:

use Getopt::Long;
GetOptions("o=s", \$plotfile,
           "v=i", \$verb,
           "xmin=f", \$xmin,
           "xmax=f", \$xmax,
           "ymin=f", \$ymin,
           "ymax=f", \$ymax,
           "color=i", \$color,
           "ls=i", \$linestyle,
           "ch=f", \$ch,
           "lw=i", \$lw,
           "e", \$errors,
           "p", \$points,
           "l", \$line,
           "logx", \$logx,
           "logy", \$logy,
           "q", \$quiet,
           "xlabel=s", \$xlabel,
           "ylabel=s", \$ylabel,
           "title=s", \$title,
           "u", \$help
           );

(defined($help)) and die "$usage\n";

(defined($verb)) or ($verb = 0);

# If -e is selected, term is the relative length of error bar terminals
(defined($errors)) and ($points = 1);
$term = 0.3;

# General character height:
(defined($ch)) or $ch = 1.5;

# General line width:
$lw0 = 2;

# Plot line width:
(defined($lw)) or $lw = $lw0;

# General line style:
$ls0 = 1;
(defined($linestyle)) and $ls = $linestyle;

# General line colour:
(defined($color)) and $ci = $color;
(defined($color)) or $ci = 1;

# Plot labelling:
(defined($xlabel)) or $xlabel = " ";
(defined($ylabel)) or $ylabel = " ";
(defined($title)) or $title = " ";


# Grab files from command line, and set up other file names:
$k = 0;
while (defined($infile = shift)){
  open (IN, $infile) or die "$infile: $!";
  close (IN);
  $file[$k] = $infile;
  $k++;
}
$nfiles = $k;

(defined($plotfile)) or ($sensible = 1);

(defined($sensible) and $nfiles > 1) and die "Must specify postscript filename with more than one file.";

if (defined($sensible)) {
   $plotfile = $file[0];
   $plotfile =~ s/(.*)\..*/$1/;
   $plotfile = $plotfile.".ps";
}

# ----------------------------------------------------------------------

# Plot twice, once to screen and once to file:

for($k=0; $k<2; $k++){

  if($k == 0){
    $device = "/xs";
    defined($quiet) and $device = "/null";
  }
  else{
     $device = "$plotfile/vcps";
  }
  ($verb == 2) and print "Device set to $device\n";

  pgbeg(0,$device,1,1);
  pgpap(0.0,0.707);
#   pgsvp(0.15,0.9,0.15,0.9);
  pgsch($ch);
  pgslw($lw0);

# Open up file, read in 2 or 3 columns, and add to plot:

  for($j=0; $j<$nfiles; $j++){

    (($verb > 0) and $k == 0) and print "Reading data from $file[$j]\n";
    open (IN, $file[$j]);

    (($verb > 1) and $k == 0) and print "Contents are: \n";
    $i = 0;
    while (<IN>){

      next if (/^\#/ or /^$/);
      chomp;
      @cols = split;

      $x[$i] = $cols[0];
      $y[$i] = $cols[1];
      $stdev[$i] = $cols[2];

      (($verb > 1) and $k == 0) and print "$x[$i] $y[$i] $stdev[$i] \n";

      if(defined($errors)){
        $ylower[$i] = $y[$i] - $stdev[$i];
        $yupper[$i] = $y[$i] + $stdev[$i];
      }

# Take logs!
      if (defined($logx)) {
        $x[$i] = log($x[$i])/log(10);
      }
      if (defined($logy)) {
        $y[$i] = log($y[$i])/log(10);
        $ylower[$i] = log($ylower[$i])/log(10);
        $yupper[$i] = log($yupper[$i])/log(10);
      }
         
      $i++;
     }
     $nlines = $i;
     (($verb > 0) and $k == 0) and print "$nlines lines read\n";

     close (IN);

     if($j == 0 and $k ==0){
        @temp = minmax(@x);
        (defined($xmin)) or $xmin = $temp[0];
        (defined($xmax)) or $xmax = $temp[1];
        @temp = minmax(@y);
        (defined($ymin)) or $ymin = $temp[0];
        (defined($ymax)) or $ymax = $temp[1];
        ($verb>0) and print "Window limits set to $xmin $xmax $ymin $ymax\n";
        (defined($logx)) and $xmin = log($xmin)/log(10);
        (defined($logx)) and $xmax = log($xmax)/log(10);
        (defined($logy)) and $ymin = log($ymin)/log(10);
        (defined($logy)) and $ymax = log($ymax)/log(10);
     }
     if($j == 0){
       pgsci(1);
#        pgwindow($xmin,$xmax,$ymin,$ymax);
#        pgbox("BCNST",0.0,0,"BCNST",0.0,0);
       if (defined($logx) and defined($logy)){
         pgenv($xmin,$xmax,$ymin,$ymax,0,30);
       } elsif (defined($logx) and ! defined($logy)){ 
         pgenv($xmin,$xmax,$ymin,$ymax,0,10);
       } elsif (! defined($logx) and defined($logy)){ 
         pgenv($xmin,$xmax,$ymin,$ymax,0,20);
       } else {  
         pgenv($xmin,$xmax,$ymin,$ymax,0,1);
       }
     }

     # white = 1, red = 2, green =3, blue =4 etc etc
<<<<<<< lineplot.pl

     (defined($color)) or $ci = $j + 1;
=======
     (defined($color)) or $ci = $j + 1;
>>>>>>> 1.4
     ($verb > 0) and print "Dataset $j: colour index set to $ci\n";
     pgsci($ci);

     # solid = 1, dashed = 2, dot-dashed =3, dotted =4

     if ( ! defined($linestyle)){
       $ls = 1;
       ($j eq 0) and $ls = 1;
       ($j eq 1) and $ls = 4;
       ($j eq 2) and $ls = 2;
       ($j eq 3) and $ls = 3;
    }
     ($verb > 0) and print "Dataset $j: line style set to $ls\n";
     pgsls($ls);

     pgslw($lw);
     defined($line) and pgline($nlines, \@x, \@y);
     
     pgslw($lw0);
     pgsls($ls0);

     defined($points) and pgpt($nlines,\@x,\@y,17);

     defined($errors) and pgerry($nlines, \@x, \@ylower, \@yupper, $term);

# End of dataset loop
   }

  pgsci(1);
  pglab("$xlabel","$ylabel","$title");
  pgend();
# End of device loop
}

# ======================================================================

sub minmax
{
    my (@numbers);

    @numbers = @_;

    my ($min, $max);

    $min = $numbers[0];
    $max = $numbers[0];

    foreach my $i (@numbers)
    {
        if ($i > $max)
        {
            $max = $i;
        }
        elsif ($i < $min)
        {
            $min = $i;
        }
    }

    return ($min, $max);
}

# ======================================================================


