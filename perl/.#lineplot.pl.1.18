#!/usr/local/bin/perl -w
# ======================================================================
#+
$usage = "\n
NAME
        lineplot.pl

PURPOSE
        Plot two or three column plain text files as connected points
        with error bars.

USAGE
        lineplot.pl [flags] [options] \$project.txt \$other.txt ...

FLAGS
        -u        Print this message
        -l        Connect points with a line
        -p        Plot data points
        -e        Plot error bars
        -logx     Logarithmic x axis
        -logy     Logarithmic y axis
        -t        Time (hh mm ss) x axis
        -q        Plot quietly (no X display)

INPUTS
        \$project.txt        3 column text file (x, y, error)

OPTIONAL INPUTS
        -v        i         Verbosity (0, 1 or 2)
        -aspect   f         aspect ratio of plot
        -xmin     f         Window xmin
        -xmax     f         xmax
        -ymin     f         ymin
        -ymax     f         ymax
        -color    i         PGPLOT color index
        -lw       i         PGPLOT line width
        -ls       i         PGPLOT line style
        -ch       f         PGPLOT character height
        -ps       i         PGPLOT point style
        -m        f	    Straight line reference gradient
        -c        f	    Straight line reference intercept
        -legend   s         File with legend text (one line per file!)
        -o        \$project Postscript output file

        \$other.txt         Additional text file

OUTPUTS
        \$project.ps        Postscript plot

COMMENTS
  - PGPLOT module requires /usr/local/bin/perl at KIPAC

EXAMPLES

BUGS
  - Colouring is hard-coded
  - No legends are added to graph

REVISION HISTORY:
  2005-08-02  Started Marshall and Cevallos (KIPAC)

\n";

#-
# ======================================================================

$sdir = $ENV{'SCRIPTUTILS_DIR'};
require($sdir."/perl/minmax.pl");

use PGPLOT;

# Parse options:

use Getopt::Long;
GetOptions("o=s", \$plotfile,
           "v=i", \$verb,
           "aspect=f", \$aspect,
           "xmin=f", \$xmin,
           "xmax=f", \$xmax,
           "ymin=f", \$ymin,
           "ymax=f", \$ymax,
           "color=i", \$color,
           "ls=i", \$linestyle,
           "ch=f", \$ch,
           "lw=i", \$lw,
           "ps=i", \$pointstyle,
           "m=f", \$m,
           "c=f", \$c,
           "e", \$errors,
           "p", \$points,
           "l", \$line,
           "logx", \$logx,
           "logy", \$logy,
           "t", \$time,
           "q", \$quiet,
           "xlabel=s", \$xlabel,
           "ylabel=s", \$ylabel,
           "title=s", \$title,
           "legend=s", \$legendfile,
           "u", \$help
           );

(defined($help)) and die "$usage\n";

(defined($verb)) or ($verb = 0);

# If -e is selected, term is the relative length of error bar terminals
(defined($errors)) and ($points = 1);
$term = 0.3;

# Aspect ratio of plot:
(defined($aspect)) or $aspect = 0.707;

# General character height:
(defined($ch)) or $ch = 1.5;

# General line width:
$lw0 = 2;

# Plot line width:
(defined($lw)) or $lw = $lw0;

# General line style:
$ls0 = 1;
$ls = 1;
(defined($linestyle)) and $ls = $linestyle;

# General line colour:
(defined($color)) and $ci = $color;
(defined($color)) or $ci = 1;

# General point style:
$ps = 17;
(defined($pointstyle)) and $ps = $pointstyle;

# Plot labelling:
(defined($xlabel)) or $xlabel = " ";
(defined($ylabel)) or $ylabel = " ";
(defined($title)) or $title = " ";

# # Reference straight line:
# $ref = 0;
# (defined($m)) and $ref = 1;
# (defined($c)) or $c = 0.0;
# if ($ref) {
#   $x1 = $xmin;
#   $y1 = $m * $x1 + $c;
#   $x2 = $xmax;
#   $y2 = $m * $x2 + $c;
#   (defined($logx)) and $x1 = log($x1)/log(10);
#   (defined($logx)) and $x2 = log($x2)/log(10);
#   (defined($logy)) and $y1 = log($y1)/log(10);
#   (defined($logy)) and $y2 = log($y2)/log(10);
#  }

# Plot limits - need to take logs if required:
(defined($xmin) and defined($logx)) and $xmin = log($xmin)/log(10);
(defined($xmax) and defined($logx)) and $xmax = log($xmax)/log(10);
(defined($ymin) and defined($logy)) and $ymin = log($ymin)/log(10);
(defined($ymax) and defined($logy)) and $ymax = log($ymax)/log(10);

# Grab files from command line, and set up other file names:
$k = 0;
while (defined($infile = shift)){
  open (IN, $infile) or die "$infile: $!";
  close (IN);
  $file[$k] = $infile;
  $k++;
}
$nfiles = $k;

(defined($plotfile)) or ($sensible = 1);

(defined($sensible) and $nfiles > 1) and die "Must specify postscript filename with more than one file.";

if (defined($sensible)) {
   $plotfile = $file[0];
   $plotfile =~ s/(.*)\..*/$1/;
   $plotfile = $plotfile.".ps";
}

$legend = 0;
(defined($legendfile)) and ($legend = 1);

# ----------------------------------------------------------------------
$ignorelessthanthis = -1e32;
$log10tiny = -32.0;

# Plot twice, once to screen and once to file:

for($k=0; $k<2; $k++){

  if($k == 0){
    $device = "/xs";
    defined($quiet) and $device = "/null";
  }
  else{
     $device = "$plotfile/vcps";
  }
  ($verb == 2) and print "Device set to $device\n";

  pgbeg(0,$device,1,1);
  pgpap(0.0,$aspect);
  pgsvp(0.15,0.9,0.2,0.9);
  pgsch($ch);
  pgslw($lw0);

# If legend required, open here:

  if ($legend){
    open (LEGEND, $legendfile);
  }

# Open up file, read in 2 or 3 columns, and add to plot:

  for($j=0; $j<$nfiles; $j++){

    (($verb > 0) and $k == 0) and print "Reading data from $file[$j]\n";
    open (IN, $file[$j]);

    (($verb > 1) and $k == 0) and print "Contents are: \n";
    $i = 0;
    while (<IN>){

      next if (/^\#/ or /^$/);
      chomp;
      @cols = split;

      $x[$i] = $cols[0];
      $y[$i] = $cols[1];
      $stdev[$i] = $cols[2];

      if (($verb > 1) and $k == 0){
        if (defined($errors)){
          print "$x[$i] $y[$i] $stdev[$i] \n";
        } else {
          print "$x[$i] $y[$i] \n";
        }
      }    

      if(defined($errors)){
        $ylower[$i] = $y[$i] - $stdev[$i];
        $yupper[$i] = $y[$i] + $stdev[$i];
      }

# Take logs!
      if (defined($logx)) {
        if ($x[$i] == 0.0){
          $x[$i] = $log10tiny;
        } else {
          $x[$i] = log($x[$i])/log(10);
        }  
      }
      if (defined($logy)) {
        if ($y[$i] == 0.0){
          $y[$i] = $log10tiny;
        } else {
          $y[$i] = log($y[$i])/log(10);
        }  
        if(defined($errors)){
          if ($y[$i] == 0.0){
            $ylower[$i] = $log10tiny;
          } else {
            $ylower[$i] = log($ylower[$i])/log(10);
          }  
          if ($yupper[$i] == 0.0){
            $yupper[$i] = $log10tiny;
          } else {
            $yupper[$i] = log($yupper[$i])/log(10);
          }  
       }  
      }
         
      $i++;
     }
     $nlines = $i;
     (($verb > 0) and $k == 0) and print "$nlines lines read\n";

     close (IN);

     if($j == 0 and $k ==0){
        @temp = minmax($ignorelessthanthis,@x);
        (defined($xmin)) or $xmin = $temp[0];
        (defined($xmax)) or $xmax = $temp[1];
        @temp = minmax($ignorelessthanthis,@y);
        (defined($ymin)) or $ymin = $temp[0];
        (defined($ymax)) or $ymax = $temp[1];
        ($verb>0) and print "Window limits set to $xmin $xmax $ymin $ymax\n";
#         (defined($logx)) and $xmin = log($xmin)/log(10);
#         (defined($logx)) and $xmax = log($xmax)/log(10);
#         (defined($logy)) and $ymin = log($ymin)/log(10);
#         (defined($logy)) and $ymax = log($ymax)/log(10);
     }
     if($j == 0){
       pgsci(1);
       pgwindow($xmin,$xmax,$ymin,$ymax);
       if (defined($time)){
         printf STDERR "calling pgtbox\n";
         pgtbox("BCNSTHYFO",0.0,0,"BCNST",0.0,0);
       } else {
         if (defined($logx) and defined($logy)){
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,30);
           pgbox("BCNSTL",0.0,0,"BCNSTL",0.0,0);
         } elsif (defined($logx) and ! defined($logy)){ 
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,10);
           pgbox("BCNSTL",0.0,0,"BCNST",0.0,0);
         } elsif (! defined($logx) and defined($logy)){ 
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,20);
           pgbox("BCNST",0.0,0,"BCNSTL",0.0,0);
         } else {  
  #          pgenv($xmin,$xmax,$ymin,$ymax,0,1);
           pgbox("BCNST",0.0,0,"BCNST",0.0,0);
         }
       }  
       pglab("$xlabel","$ylabel","$title");
       if ($legend){
         if ($k == 0){
           printf STDERR "  Use cursor to select legend position...\n";
           $char = "x";
           $lx0 = 0.5*($xmin+$xmax);
           $ly0 = 0.5*($ymin+$ymax);
           pgcurs($lx0,$ly0,$char);
           pgqcs(4,$dx,$dy)
         }  
         $lx = $lx0;
         $ly = $ly0;
       }  
     } else {
        if ($legend){
          $ly = $ly - 1.3*$dy;
        }  
     }

#      # white = 1, red = 2, green =3, blue =4 etc etc
#      (defined($color)) or $ci = $j + 1;
     
#      # String paper scheme (red, green, blue, ...)!
#      @colourindex = (2,3,4,1,5,6,7,8,9,10,11,12);
#      (defined($color)) or $ci = $colourindex[$j];
     
     # Nice scheme (grey, red, blue...)!
     @colourindex = (8,8,11,11);
     (defined($color)) or $ci = $colourindex[$j];
     
#      # Filters and spectra (grey, grey, red, blue...)!
#      @colourindex = (14,14,8,11);
#      (defined($color)) or $ci = $colourindex[$j];
     
     ($verb > 0) and print "Dataset $j: colour index set to $ci\n";
     pgsci($ci);

#      # solid = 1, dashed = 2, dot-dashed =3, dotted =4
#      @linestyleindex = (1,4,2,3);
     
#      # String paper scheme (green, red, blue, ...)!
#      @linestyleindex = (1,2,4,3,1);

     # Nice scheme!
     @linestyleindex = (1,4,1,4);

#      # Filters and spectra (grey, grey, red, blue...)!
#      @linestyleindex = (4,4,1,1);
     
     (defined($linestyle)) or $ls = $linestyleindex[$j];
     
#      if ( ! defined($linestyle)){
#        $ls = 1;
#        ($j eq 0) and $ls = 1;
#        ($j eq 1) and $ls = 4;
#        ($j eq 2) and $ls = 2;
#        ($j eq 3) and $ls = 3;
#      }

     ($verb > 0) and print "Dataset $j: line style set to $ls\n";
     pgsls($ls);

     pgslw($lw);
     defined($line) and pgline($nlines, \@x, \@y);
     
     pgslw($lw0);
     pgsls($ls0);

     if (defined($points)) {
       pgsch(1.5);
       pgpt($nlines,\@x,\@y,-$ps);
       pgsch($ch);
     }  

     defined($errors) and pgerry($nlines, \@x, \@ylower, \@yupper, $term);

# Add legend if required:

     if ($legend){
       $text = readline LEGEND;
       chomp($text);
       $x1 = $lx;
       $y1 = $ly + 0.3*$dy;
       pgmove($x1,$y1);
       $x2 = $lx + 3*$dx;
       $y2 = $y1;
       pgslw($lw);
       pgsls($ls);
       pgdraw($x2,$y2);
       pgsci(1);
       pgslw($lw0);
       pgsls($ls0);
       pgsch($ch);
       $x3 = $lx + 4*$dx;
       $y3 = $ly;
       pgtext($x3,$y3,$text);
     }

# End of dataset loop
  }
  ($legend) and close (LEGEND);

# Reference straight line (dotted):

  $ref = 0;
  (defined($m)) and $ref = 1;
  (defined($c)) or $c = 0.0;
  if ($ref) {
    $x1 = $xmin;
    (defined($logx)) and $x1 = exp($x1*log(10));
    $x2 = $xmax;
    (defined($logx)) and $x2 = exp($x2*log(10));
    $y1 = $m * $x1 + $c;
    $y2 = $m * $x2 + $c;
    (defined($logx)) and $x1 = log($x1)/log(10);
    (defined($logx)) and $x2 = log($x2)/log(10);
    (defined($logy)) and $y1 = log($y1)/log(10);
    (defined($logy)) and $y2 = log($y2)/log(10);
  }

  pgsci(1);
  if ($ref) {
    pgslw($lw);
    pgsls($ls);
    pgmove($x1,$y1);
    pgdraw($x2,$y2);
    pgslw($lw0);
    pgsls($ls0);
  }  

  pglab("$xlabel","$ylabel","$title");
  pgend();
# End of device loop
}

# ======================================================================
